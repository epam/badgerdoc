import logging
import os
from datetime import datetime, timezone
from typing import Optional

import sqlalchemy
from sqlalchemy.ext.asyncio import AsyncSession

from veeva.models.configuration import Configuration, SyncProtocol, SyncType

logger = logging.getLogger(__name__)
logger.setLevel(os.getenv("LOG_LEVEL", "INFO"))


class ConfigurationNotFoundError(Exception):
    pass


async def create(
    session: AsyncSession,
    user: str,
    tenant: str,
    sync_type: SyncType,
    protocol: SyncProtocol,
    veeva_pm_host: str,
    veeva_pm_login: str,
    # TODO: add option to store in Secrets Manager
    veeva_pm_password: str,
    veeva_pm_vql: str,
) -> Configuration:
    """
    Create a new Veeva PM configuration.

    This function creates a new configuration entry for Veeva PM integration,
    storing connection details and synchronization preferences.

    Args:
        session: The async SQLAlchemy session for database operations
        user: Username of the person creating the configuration
        tenant: Tenant identifier for multi-tenancy support
        sync_type: Type of synchronization (Documents or Mappings)
        protocol: Communication protocol to use (RestAPI or VaultLoader)
        veeva_pm_host: Hostname for the Veeva PM instance
        veeva_pm_login: Login username for Veeva PM authentication
        veeva_pm_password: Password for Veeva PM authentication
        veeva_pm_vql: Optional VQL (Veeva Query Language) query for document filtering

    Returns:
        Configuration: The newly created configuration with its autogenerated ID

    Raises:
        SQLAlchemyError: If there's an issue with the database operation
    """
    logger.debug("Creating Veeva PM configuration for tenant: %s", tenant)
    new_config = Configuration(
        tenant=tenant,
        created_by=user,
        sync_type=sync_type.value,
        protocol=protocol.value,
        veeva_pm_host=veeva_pm_host,
        veeva_pm_login=veeva_pm_login,
        veeva_pm_password=veeva_pm_password,
        veeva_pm_vql=veeva_pm_vql,
    )
    session.add(new_config)
    await session.commit()
    await session.refresh(new_config)  # Refresh to get the ID from the database

    logger.debug(
        "Created new Veeva PM configuration with ID %d for tenant %s",
        new_config.id,
        tenant,
    )
    return new_config


async def update(
    session: AsyncSession,
    configuration_id: int,
    user: str,
    tenant: str,
    veeva_pm_host: str,
    veeva_pm_login: str,
    veeva_pm_password: str,
    veeva_pm_vql: Optional[str] = None,
) -> Optional[Configuration]:
    """
    Update an existing Veeva PM configuration.

    Args:
        session: The async SQLAlchemy session for database operations
        configuration_id: ID of the configuration to update
        user: Username of the person updating the configuration
        tenant: Tenant identifier for multi-tenancy support
        veeva_pm_host: Hostname for the Veeva PM instance
        veeva_pm_login: Login username for Veeva PM authentication
        veeva_pm_password: Password for Veeva PM authentication
        veeva_pm_vql: Optional VQL query for document filtering

    Returns:
        Configuration: The updated configuration if found, None if not found

    Raises:
        SQLAlchemyError: If there's an issue with the database operation
    """
    logger.debug(
        "Updating Veeva PM configuration ID %d for tenant %s", configuration_id, tenant
    )

    stmt = (
        sqlalchemy.update(Configuration)
        .where(
            (Configuration.id == configuration_id)
            & (~Configuration.soft_deleted)
            & (Configuration.tenant == tenant)
        )
        .values(
            updated_by=user,
            updated_at=datetime.now(timezone.utc),
            veeva_pm_host=veeva_pm_host,
            veeva_pm_login=veeva_pm_login,
            veeva_pm_password=veeva_pm_password,
            veeva_pm_vql=veeva_pm_vql,
        )
        .returning(Configuration)
    )

    result = await session.execute(stmt)
    updated_config = result.scalar_one_or_none()
    await session.commit()

    if updated_config is None:
        raise ConfigurationNotFoundError(
            f"Configuration with ID {configuration_id} not found or already soft deleted"
        )

    return updated_config


async def delete(
    session: AsyncSession,
    configuration_id: int,
    tenant: str,
    user: str,
) -> None:
    """
    Soft delete a Veeva PM configuration.

    Args:
        session: The async SQLAlchemy session for database operations
        configuration_id: ID of the configuration to delete

    Raises:
        ValueError: If the configuration with the given ID does not exist
    """
    logger.debug("Soft deleting Veeva PM configuration ID %d", configuration_id)

    stmt = (
        sqlalchemy.update(Configuration)
        .where(
            (Configuration.id == configuration_id)
            & (~Configuration.soft_deleted)
            & (Configuration.tenant == tenant)
        )
        .values(
            updated_by=user, soft_deleted=True, updated_at=datetime.now(timezone.utc)
        )
        .returning(Configuration)
    )

    result = await session.execute(stmt)
    updated_config = result.scalar_one_or_none()
    await session.commit()

    if updated_config is None:
        raise ConfigurationNotFoundError(
            f"Configuration with ID {configuration_id} not found or already soft deleted"
        )

    logger.debug("Soft deleted Veeva PM configuration ID %d", configuration_id)
    return updated_config
